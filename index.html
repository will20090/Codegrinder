<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codebusters Practice</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .content {
            padding: 30px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 18px;
        }

        .error {
            background: #ffebee;
            border: 2px solid #f44336;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            color: #c62828;
        }

        .cryptogram-display {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            line-height: 1.6;
            min-height: 200px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .cipher-line {
            margin-bottom: 5px;
            color: #2c3e50;
            font-weight: bold;
        }

        .plain-line {
            margin-bottom: 20px;
            color: #27ae60;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="text"] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        button {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        button.danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        button.success {
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        .puzzle-options {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .option-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .option-group h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .radio-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .frequency-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid #e9ecef;
        }

        .frequency-section h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
        }

        .frequency-table {
            display: grid;
            grid-template-columns: repeat(26, 1fr);
            gap: 2px;
            margin-bottom: 15px;
        }

        .freq-cell {
            text-align: center;
            padding: 8px 2px;
            background: white;
            border: 1px solid #ddd;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .freq-header {
            background: #3498db;
            color: white;
        }

        .freq-input {
            width: 30px;
            height: 35px;
            text-align: center;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 14px;
        }

        .freq-input:focus {
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .input-row {
            display: grid;
            grid-template-columns: repeat(26, 1fr);
            gap: 2px;
            margin-top: 10px;
        }

        .status {
            background: #e8f4fd;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            font-weight: bold;
            color: #2c3e50;
        }

        .substitution-display {
            color: #27ae60;
        }

        .underscore {
            color: #95a5a6;
        }

        .file-stats {
            background: #f0f8ff;
            border: 2px solid #4169e1;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #2c3e50;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }

            .content {
                padding: 20px;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .puzzle-options {
                flex-direction: column;
            }

            .frequency-table {
                grid-template-columns: repeat(13, 1fr);
            }

            .input-row {
                grid-template-columns: repeat(13, 1fr);
            }

            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê Codebusters Practice</h1>
        </div>
        
        <div class="content">
            <div id="loadingMessage" class="loading">
                üìÇ Loading quotes and keywords from files...
            </div>

            <div id="errorMessage" class="error" style="display: none;">
                ‚ö†Ô∏è Could not load external files. Using built-in content instead.
                <br><small>If you have custom files (quotes.json, spanishQuotes.txt, words.txt), make sure they're in the same directory.</small>
            </div>

            <div id="fileStats" class="file-stats" style="display: none;">
                üìä Loaded: <span id="statsText"></span>
            </div>

            <div id="gameContent" style="display: none;">
                <div class="puzzle-options">
                    <div class="option-group">
                        <h4>Puzzle Type</h4>
                        <div class="radio-group">
                            <label class="radio-item">
                                <input type="radio" name="puzzleType" value="aristocrat" checked>
                                Aristocrat
                            </label>
                            <label class="radio-item">
                                <input type="radio" name="puzzleType" value="patristocrat">
                                Patristocrat
                            </label>
                            <label class="radio-item">
                                <input type="radio" name="puzzleType" value="xenocrypt">
                                Xenocrypt
                            </label>
                        </div>
                    </div>
                    
                    <div class="option-group">
                        <h4>Cipher Mapping</h4>
                        <div class="radio-group">
                            <label class="radio-item">
                                <input type="radio" name="cipherType" value="random" checked>
                                Random
                            </label>
                            <label class="radio-item">
                                <input type="radio" name="cipherType" value="k1">
                                K1 (Keyword)
                            </label>
                            <label class="radio-item">
                                <input type="radio" name="cipherType" value="k2">
                                K2 (Keyword)
                            </label>
                            <label class="radio-item">
                                <input type="radio" name="cipherType" value="k3">
                                K3 (Keyword)
                            </label>
                        </div>
                    </div>
                </div>

                <div class="cryptogram-display" id="cryptogramDisplay">
                    Ready to generate puzzle...
                </div>

                <div class="controls">
                    <div class="control-group">
                        <label>Substitution (e.g., X E):</label>
                        <input type="text" id="substitutionInput" placeholder="X E" maxlength="3">
                        <button onclick="processSubstitution()">Apply</button>
                    </div>
                    <button onclick="checkSolution()" class="success">Check Solution</button>
                    <button onclick="loadNewPuzzle()">New Puzzle</button>
                    <button onclick="showHint()">First Word Hint</button>
                    <button onclick="guessKeyword()">Guess Keyword</button>
                    <button onclick="revealAnswer()" class="danger">Reveal Answer</button>
                </div>

                <div class="frequency-section">
                    <h3>Letter Frequency & Substitution</h3>
                    <div class="frequency-table" id="frequencyTable">
                        <!-- Frequency display will be generated here -->
                    </div>
                    <div class="input-row" id="inputRow">
                        <!-- Input fields will be generated here -->
                    </div>
                </div>

                <div class="status" id="statusLabel">
                    Click "New Puzzle" to start solving!
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let currentQuote = '';
        let encodedText = '';
        let cipher = {};
        let guesses = {};
        let isAristocrat = true;
        let isXenocrypt = false;
        let currentKeyword = '';
        let mappingType = 'random';
        let firstWord = '';

        // Data loaded from files
        let englishQuotes = [];
        let spanishQuotes = [];
        let keywords = [];
        let filesLoaded = false;

        // File loading functions
        async function loadFiles() {
            const maxLoadTime = 5000; // 5 seconds timeout
            const loadingTimeout = setTimeout(() => {
                console.warn('File loading timeout - proceeding with fallback data');
                useFallbackData();
                showGameContent();
            }, maxLoadTime);

            try {
                updateLoadingMessage('Loading English quotes from quotes.json...');
                await loadEnglishQuotes();
                
                updateLoadingMessage('Loading Spanish quotes from spanishQuotes.txt...');
                await loadSpanishQuotes();
                
                updateLoadingMessage('Loading keywords from words.txt...');
                await loadKeywords();
                
                clearTimeout(loadingTimeout);
                filesLoaded = true;
                showGameContent();
                updateFileStats();
                
            } catch (error) {
                clearTimeout(loadingTimeout);
                console.error('Error loading files:', error);
                useFallbackData();
                showError();
            }
        }

        function useFallbackData() {
            // Set fallback data if files can't be loaded
            if (englishQuotes.length === 0) {
                englishQuotes = [
                    "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
                    "TO BE OR NOT TO BE THAT IS THE QUESTION",
                    "ALL THE WORLD IS A STAGE AND ALL THE MEN AND WOMEN MERELY PLAYERS",
                    "LIFE IS WHAT HAPPENS WHEN YOU ARE BUSY MAKING OTHER PLANS",
                    "THE ONLY WAY TO DO GREAT WORK IS TO LOVE WHAT YOU DO",
                    "KNOWLEDGE IS POWER BUT ENTHUSIASM PULLS THE SWITCH",
                    "SUCCESS IS NOT FINAL FAILURE IS NOT FATAL IT IS THE COURAGE TO CONTINUE THAT COUNTS",
                    "THE FUTURE BELONGS TO THOSE WHO BELIEVE IN THE BEAUTY OF THEIR DREAMS",
                    "IT IS DURING OUR DARKEST MOMENTS THAT WE MUST FOCUS TO SEE THE LIGHT",
                    "BELIEVE YOU CAN AND YOU ARE HALFWAY THERE"
                ];
            }

            if (spanishQuotes.length === 0) {
                spanishQuotes = [
                    "EL ZORRO MARR√ìN R√ÅPIDO SALTA SOBRE EL PERRO PEREZOSO",
                    "LA VIDA ES LO QUE PASA MIENTRAS EST√ÅS OCUPADO HACIENDO OTROS PLANES",
                    "EL √öNICO MODO DE HACER UN GRAN TRABAJO ES AMAR LO QUE HACES",
                    "EL CONOCIMIENTO ES PODER PERO EL ENTUSIASMO TIRA DEL INTERRUPTOR",
                    "EL FUTURO PERTENECE A AQUELLOS QUE CREEN EN LA BELLEZA DE SUS SUE√ëOS"
                ];
            }

            if (keywords.length === 0) {
                keywords = [
                    "PUZZLE", "CIPHER", "SECRET", "HIDDEN", "MYSTERY", "ENIGMA", 
                    "CODING", "CRYPTO", "SOLVER", "BREAK", "DECODE", "REVEAL",
                    "ALGORITHM", "PATTERN", "FREQUENCY", "SUBSTITUTION", "ENCRYPT",
                    "CHALLENGE", "BRAIN", "LOGIC", "THINK", "ANALYZE", "DISCOVER"
                ];
            }

            filesLoaded = true;
            updateFileStats();
        }

        async function loadEnglishQuotes() {
            try {
                const response = await fetch('quotes.json');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                
                // Handle different JSON structures
                if (Array.isArray(data)) {
                    englishQuotes = data.map(item => 
                        typeof item === 'string' ? item.toUpperCase() : 
                        (item.Quote || item.quote || item.text || item.content || '').toUpperCase()
                    ).filter(quote => quote.length > 0);
                } else if (data.quotes && Array.isArray(data.quotes)) {
                    englishQuotes = data.quotes.map(item => 
                        typeof item === 'string' ? item.toUpperCase() : 
                        (item.Quote || item.quote || item.text || item.content || '').toUpperCase()
                    ).filter(quote => quote.length > 0);
                } else {
                    throw new Error('Invalid JSON structure');
                }
                
                if (englishQuotes.length === 0) {
                    throw new Error('No valid quotes found in quotes.json');
                }
                
            } catch (error) {
                // Will use fallback quotes
                throw error;
            }
        }

        async function loadSpanishQuotes() {
            try {
                const response = await fetch('spanishQuotes.txt');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const text = await response.text();
                
                // Try to parse as JSON first (since your file is actually JSON)
                try {
                    const data = JSON.parse(text);
                    if (data.quotes && Array.isArray(data.quotes)) {
                        spanishQuotes = data.quotes.map(item => 
                            (item.Cita || item.cita || item.quote || item.Quote || '').toUpperCase()
                        ).filter(quote => quote.length > 0);
                    } else if (Array.isArray(data)) {
                        spanishQuotes = data.map(item => 
                            typeof item === 'string' ? item.toUpperCase() : 
                            (item.Cita || item.cita || item.quote || item.Quote || '').toUpperCase()
                        ).filter(quote => quote.length > 0);
                    } else {
                        throw new Error('Invalid JSON structure for Spanish quotes');
                    }
                } catch (jsonError) {
                    // If JSON parsing fails, try as plain text
                    spanishQuotes = text.split('\n')
                        .map(line => line.trim().toUpperCase())
                        .filter(line => line.length > 0);
                }
                
                if (spanishQuotes.length === 0) {
                    throw new Error('No quotes found in spanishQuotes.txt');
                }
                
            } catch (error) {
                // Will use fallback quotes
                throw error;
            }
        }

        async function loadKeywords() {
            try {
                const response = await fetch('words.txt');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const text = await response.text();
                keywords = text.split(/\r?\n/)
                    .map(line => line.trim().toUpperCase())
                    .filter(line => line.length > 0 && /^[A-Z]+$/.test(line));
                
                if (keywords.length === 0) {
                    throw new Error('No keywords found in words.txt');
                }
                
            } catch (error) {
                // Will use fallback keywords
                throw error;
            }
        }

        function updateLoadingMessage(message) {
            document.getElementById('loadingMessage').textContent = message;
        }

        function showError() {
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('errorMessage').style.display = 'block';
            document.getElementById('fileStats').style.display = 'block';
            document.getElementById('gameContent').style.display = 'block';
        }

        function showGameContent() {
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('fileStats').style.display = 'block';
            document.getElementById('gameContent').style.display = 'block';
        }

        function updateFileStats() {
            const statsText = `${englishQuotes.length} English quotes, ${spanishQuotes.length} Spanish quotes, ${keywords.length} keywords`;
            document.getElementById('statsText').textContent = statsText;
        }

        // Initialize the game
        function init() {
            loadFiles().then(() => {
                setupEventHandlers();
                createFrequencyTable();
                loadNewPuzzle();
            });
        }

        function setupEventHandlers() {
            // Puzzle type handlers
            document.querySelectorAll('input[name="puzzleType"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    isAristocrat = this.value === 'aristocrat';
                    isXenocrypt = this.value === 'xenocrypt';
                    loadNewPuzzle();
                });
            });

            // Cipher type handlers
            document.querySelectorAll('input[name="cipherType"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    mappingType = this.value;
                    loadNewPuzzle();
                });
            });

            // Substitution input handler
            document.getElementById('substitutionInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    processSubstitution();
                }
            });
        }

        function createFrequencyTable() {
            const table = document.getElementById('frequencyTable');
            const inputRow = document.getElementById('inputRow');
            
            table.innerHTML = '';
            inputRow.innerHTML = '';

            // Create header row with letters
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const headerCell = document.createElement('div');
                headerCell.className = 'freq-cell freq-header';
                headerCell.textContent = letter;
                table.appendChild(headerCell);
            }

            // Create frequency count row
            for (let i = 0; i < 26; i++) {
                const freqCell = document.createElement('div');
                freqCell.className = 'freq-cell';
                freqCell.id = `freq-${String.fromCharCode(65 + i)}`;
                freqCell.textContent = '0';
                table.appendChild(freqCell);
            }

            // Create input row
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'freq-input';
                input.maxLength = 1;
                input.id = `input-${letter}`;
                
                input.addEventListener('input', function() {
                    const value = this.value.toUpperCase();
                    if (value && /[A-Z]/.test(value)) {
                        guesses[letter] = value;
                        this.value = value;
                    } else {
                        delete guesses[letter];
                        this.value = '';
                    }
                    updateDisplay();
                    updateFrequencyTable();
                });

                inputRow.appendChild(input);
            }
        }

        function loadNewPuzzle() {
            if (!filesLoaded) return;
            
            guesses = {};
            
            // Select quote based on puzzle type
            const quotes = isXenocrypt ? spanishQuotes : englishQuotes;
            if (quotes.length === 0) {
                updateStatus('No quotes available for this puzzle type');
                return;
            }
            
            currentQuote = quotes[Math.floor(Math.random() * quotes.length)];
            
            // Clean quotes (remove surrounding quotes and escape characters)
            currentQuote = currentQuote.replace(/^"|"$|\\"/g, '');
            
            // Get first word for hints
            const words = currentQuote.trim().split(/\s+/);
            firstWord = words.length > 0 ? words[0].replace(/[^A-Z]/g, '') : '';

            // Generate cipher
            if (mappingType === 'random') {
                cipher = generateRandomCipher();
                currentKeyword = '';
            } else {
                if (keywords.length === 0) {
                    updateStatus('No keywords available for cipher generation');
                    return;
                }
                currentKeyword = keywords[Math.floor(Math.random() * keywords.length)];
                cipher = generateKeywordCipher(currentKeyword, mappingType);
            }

            // Encode text
            encodedText = isAristocrat ? encodeAristocrat(currentQuote) : encodePatristocrat(currentQuote);

            // Clear input fields
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const input = document.getElementById(`input-${letter}`);
                if (input) input.value = '';
            }

            updateDisplay();
            updateFrequencyTable();
            updateStatus(`New ${isXenocrypt ? 'Xenocrypt' : isAristocrat ? 'Aristocrat' : 'Patristocrat'} puzzle loaded!`);
        }

        function generateRandomCipher() {
            const plainAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
            const cipherAlphabet = [...plainAlphabet];
            
            // Fisher-Yates shuffle
            for (let i = cipherAlphabet.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [cipherAlphabet[i], cipherAlphabet[j]] = [cipherAlphabet[j], cipherAlphabet[i]];
            }

            // Ensure no letter maps to itself
            for (let i = 0; i < 26; i++) {
                if (plainAlphabet[i] === cipherAlphabet[i]) {
                    // Swap with next position (or first if at end)
                    const swapIndex = (i + 1) % 26;
                    [cipherAlphabet[i], cipherAlphabet[swapIndex]] = [cipherAlphabet[swapIndex], cipherAlphabet[i]];
                }
            }

            const result = {};
            for (let i = 0; i < 26; i++) {
                result[plainAlphabet[i]] = cipherAlphabet[i];
            }
            return result;
        }

   function generateKeywordCipher(keyword, type) {
            let plaintextAlphabet = [];
            let cipherAlphabet = [];

            if (type === 'k1') {
                // K1: keyword + remaining alphabet (matches Java logic)
                const used = new Set();
                
                // Add keyword letters first
                for (let c of keyword.toUpperCase()) {
                    if (/[A-Z]/.test(c) && !used.has(c)) {
                        plaintextAlphabet.push(c);
                        used.add(c);
                    }
                }
                
                // Add remaining alphabet letters
                for (let c = 'A'.charCodeAt(0); c <= 'Z'.charCodeAt(0); c++) {
                    const letter = String.fromCharCode(c);
                    if (!used.has(letter)) {
                        plaintextAlphabet.push(letter);
                    }
                }
                
                // Create cipher alphabet A-Z
                for (let c = 'A'.charCodeAt(0); c <= 'Z'.charCodeAt(0); c++) {
                    cipherAlphabet.push(String.fromCharCode(c));
                }
                
            } else if (type === 'k2') {
                // K2: interleave keyword with alphabet (matches Java logic)
                plaintextAlphabet = [];
                for (let c = 'A'.charCodeAt(0); c <= 'Z'.charCodeAt(0); c++) {
                    plaintextAlphabet.push(String.fromCharCode(c));
                }
                
                cipherAlphabet = [];
                const used = new Set();
                
                // Clean keyword (remove duplicates)
                const cleanKeyword = [];
                for (let c of keyword.toUpperCase()) {
                    if (/[A-Z]/.test(c) && !used.has(c)) {
                        cleanKeyword.push(c);
                        used.add(c);
                    }
                }
                used.clear();
                
                let keyIndex = 0;
                let alphabetIndex = 0;
                
                while (cipherAlphabet.length < 26) {
                    // Add keyword letter
                    if (keyIndex < cleanKeyword.length) {
                        const k = cleanKeyword[keyIndex++];
                        if (!used.has(k)) {
                            cipherAlphabet.push(k);
                            used.add(k);
                        }
                    }
                    
                    // Add alphabet letter
                    while (alphabetIndex < 26 && cipherAlphabet.length < 26) {
                        const a = String.fromCharCode('A'.charCodeAt(0) + alphabetIndex++);
                        if (!used.has(a)) {
                            cipherAlphabet.push(a);
                            used.add(a);
                            break;
                        }
                    }
                }
                
            } else if (type === 'k3') {
                // K3: keyword + remaining alphabet, then reverse (matches Java logic)
                const usedLetters = new Set();
                
                // Add keyword letters first
                for (let c of keyword.toUpperCase()) {
                    if (/[A-Z]/.test(c) && !usedLetters.has(c)) {
                        plaintextAlphabet.push(c);
                        usedLetters.add(c);
                    }
                }
                
                // Add remaining alphabet letters
                for (let c = 'A'.charCodeAt(0); c <= 'Z'.charCodeAt(0); c++) {
                    const letter = String.fromCharCode(c);
                    if (!usedLetters.has(letter)) {
                        plaintextAlphabet.push(letter);
                    }
                }
                
                // Cipher alphabet is plaintext alphabet reversed
                cipherAlphabet = [...plaintextAlphabet].reverse();
            }

            // Apply random shift (matches Java currentShift)
            const shift = Math.floor(Math.random() * 26);
            cipherAlphabet = cipherAlphabet.slice(shift).concat(cipherAlphabet.slice(0, shift));

            // Fix self-mappings with the same logic as Java
            let needFixing;
            do {
                needFixing = false;
                for (let i = 0; i < 26; i++) {
                    if (plaintextAlphabet[i] === cipherAlphabet[i]) {
                        needFixing = true;
                        // Find a position that doesn't have self-mapping after previous fixes
                        for (let j = 0; j < 26; j++) {
                            if (i !== j && 
                                plaintextAlphabet[j] !== cipherAlphabet[i] && 
                                plaintextAlphabet[i] !== cipherAlphabet[j]) {
                                // Swap them
                                [cipherAlphabet[i], cipherAlphabet[j]] = [cipherAlphabet[j], cipherAlphabet[i]];
                                break;
                            }
                        }
                    }
                }
            } while (needFixing);

            const result = {};
            for (let i = 0; i < 26; i++) {
                result[plaintextAlphabet[i]] = cipherAlphabet[i];
            }
            return result;
        }

        function encodeAristocrat(text) {
            return text.split('').map(c => {
                if (/[A-Z]/.test(c)) return cipher[c];
                if (/[a-z]/.test(c)) return cipher[c.toUpperCase()];
                return c;
            }).join('');
        }

        function encodePatristocrat(text) {
            return text.split('').map(c => {
                if (/[A-Za-z]/.test(c)) return cipher[c.toUpperCase()];
                return '';
            }).join('');
        }

        function updateDisplay() {
            const display = document.getElementById('cryptogramDisplay');
            
            if (isAristocrat) {
                // Aristocrat format: preserve spaces and punctuation
                const lines = splitIntoLines(encodedText, 60);
                let html = '';
                
                lines.forEach(line => {
                    // Cipher line
                    html += '<div class="cipher-line">';
                    for (let c of line) {
                        html += `<span>${c}</span>`;
                    }
                    html += '</div>';
                    
                    // Plain line
                    html += '<div class="plain-line">';
                    for (let c of line) {
                        if (/[A-Z]/.test(c)) {
                            if (guesses[c]) {
                                html += `<span class="substitution-display">${guesses[c]}</span>`;
                            } else {
                                html}
                    }
                });
                html += '</div>';
                
                display.innerHTML = html;
            }
        }

        function splitIntoLines(text, maxLength) {
            const lines = [];
            let currentLine = '';
            const words = text.split(' ');
            
            for (let word of words) {
                if (currentLine.length + word.length + 1 <= maxLength) {
                    currentLine += (currentLine ? ' ' : '') + word;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine) lines.push(currentLine);
            
            return lines;
        }

        function updateFrequencyTable() {
            // Count letter frequencies in cipher text
            const frequencies = {};
            for (let i = 0; i < 26; i++) {
                frequencies[String.fromCharCode(65 + i)] = 0;
            }

            for (let c of encodedText) {
                if (/[A-Z]/.test(c)) {
                    frequencies[c]++;
                }
            }

            // Update frequency display
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const cell = document.getElementById(`freq-${letter}`);
                if (cell) {
                    cell.textContent = frequencies[letter];
                }
            }

            // Update input field backgrounds based on guesses
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const input = document.getElementById(`input-${letter}`);
                if (input) {
                    if (guesses[letter]) {
                        input.style.backgroundColor = '#e8f5e8';
                        input.style.color = '#27ae60';
                    } else {
                        input.style.backgroundColor = '';
                        input.style.color = '';
                    }
                }
            }
        }

        function processSubstitution() {
            const input = document.getElementById('substitutionInput');
            const value = input.value.trim().toUpperCase();
            
            if (value.length === 3 && value[1] === ' ') {
                const cipher = value[0];
                const plain = value[2];
                
                if (/[A-Z]/.test(cipher) && /[A-Z]/.test(plain)) {
                    guesses[cipher] = plain;
                    
                    // Update frequency table input
                    const freqInput = document.getElementById(`input-${cipher}`);
                    if (freqInput) {
                        freqInput.value = plain;
                    }
                    
                    updateDisplay();
                    updateFrequencyTable();
                    input.value = '';
                    updateStatus(`Substitution applied: ${cipher} ‚Üí ${plain}`);
                } else {
                    updateStatus('Invalid substitution format. Use format: X E');
                }
            } else {
                updateStatus('Invalid format. Use: CIPHER PLAIN (e.g., X E)');
            }
        }

        function checkSolution() {
            // Create reverse cipher mapping
            const reverseCipher = {};
            for (let [plain, cipherLetter] of Object.entries(cipher)) {
                reverseCipher[cipherLetter] = plain;
            }

            let correct = 0;
            let total = 0;

            for (let [cipherLetter, guessedPlain] of Object.entries(guesses)) {
                total++;
                if (reverseCipher[cipherLetter] === guessedPlain) {
                    correct++;
                }
            }

            if (total === 0) {
                updateStatus('No substitutions made yet');
                return;
            }

            const percentage = Math.round((correct / total) * 100);
            
            if (correct === total && total === 26) {
                updateStatus(`üéâ Perfect! You solved the puzzle completely! (${correct}/${total} correct)`);
            } else if (percentage >= 80) {
                updateStatus(`üéØ Excellent progress! ${correct}/${total} correct (${percentage}%)`);
            } else if (percentage >= 60) {
                updateStatus(`üëç Good work! ${correct}/${total} correct (${percentage}%)`);
            } else {
                updateStatus(`üìà Keep going! ${correct}/${total} correct (${percentage}%)`);
            }
        }

        function showHint() {
            if (!firstWord) {
                updateStatus('No hint available for this puzzle');
                return;
            }
            
            updateStatus(`üí° Hint: The first word is "${firstWord}"`);
        }

        function guessKeyword() {
            if (!currentKeyword) {
                updateStatus('This puzzle was not generated with a keyword');
                return;
            }
            
            updateStatus(`üóùÔ∏è Keyword hint: The keyword is "${currentKeyword}"`);
        }

        function revealAnswer() {
            if (!confirm('Are you sure you want to reveal the answer? This will show the complete solution.')) {
                return;
            }

            // Create reverse cipher mapping
            const reverseCipher = {};
            for (let [plain, cipherLetter] of Object.entries(cipher)) {
                reverseCipher[cipherLetter] = plain;
            }

            // Fill in all guesses
            guesses = { ...reverseCipher };

            // Update all input fields
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const input = document.getElementById(`input-${letter}`);
                if (input && reverseCipher[letter]) {
                    input.value = reverseCipher[letter];
                }
            }

            updateDisplay();
            updateFrequencyTable();
            updateStatus(`üìñ Answer revealed: "${currentQuote}"`);
        }

        function updateStatus(message) {
            document.getElementById('statusLabel').textContent = message;
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
