<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aristocrat Cipher Practice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: shimmer 6s infinite;
        }
        @keyframes shimmer {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(180deg); }
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
            position: relative;
            z-index: 1;
        }
        .content {
            padding: 30px;
        }
        .section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.4em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        .controls {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .control-group label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 1em;
            margin-bottom: 5px;
        }
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        .radio-option:hover {
            background-color: #f8f9fa;
        }
        .radio-option input[type="radio"] {
            margin: 0;
        }
        .radio-option label {
            margin: 0;
            cursor: pointer;
            font-weight: normal;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 5px;
        }
        .checkbox-container input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
        .keyword-guess {
            margin-top: 15px;
        }
        .keyword-input {
            padding: 8px 12px;
            border: 2px solid #3498db;
            border-radius: 5px;
            font-size: 1em;
            width: 200px;
            margin-right: 10px;
        }
        .btn-small {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }
        .btn-small:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .cipher-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            line-height: 1.8;
        }
        .cipher-text-line {
            display: flex;
            gap: 1px;
            flex-wrap: wrap;
            align-items: flex-start;
            justify-content: flex-start;
            margin-bottom: 15px;
        }
        .cipher-pair {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 1px;
        }
        .cipher-letter {
            font-size: 1.1em;
            font-weight: bold;
            color: #2c3e50;
            background: #fff3cd;
            padding: 6px 4px;
            border-radius: 4px;
            min-width: 28px;
            text-align: center;
            border: 2px solid #ffc107;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .space-marker {
            width: 15px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1em;
            color: #6c757d;
        }
        .line-break {
            width: 100%;
            height: 10px;
        }
        .answer-box {
            width: 28px;
            height: 28px;
            border: 2px solid #3498db;
            border-radius: 4px;
            text-align: center;
            font-size: 0.95em;
            font-weight: bold;
            background: white;
            outline: none;
            transition: all 0.3s ease;
            margin-top: 2px;
        }
        .answer-box:focus {
            border-color: #2980b9;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.3);
        }
        .freq-table {
            display: grid;
            grid-template-columns: repeat(26, 1fr);
            gap: 4px;
            margin-top: 15px;
            max-width: 100%;
            overflow-x: auto;
        }
        .freq-entry {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f8f9fa;
            border-radius: 6px;
            padding: 6px 3px;
            border: 1px solid #dee2e6;
            min-width: 35px;
        }
        .freq-cipher {
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.95em;
            margin-bottom: 3px;
        }
        .freq-count {
            font-size: 0.8em;
            color: #6c757d;
            margin-bottom: 3px;
        }
        .freq-input {
            width: 26px;
            height: 22px;
            border: 1px solid #3498db;
            border-radius: 3px;
            text-align: center;
            font-size: 0.85em;
            font-weight: bold;
        }
        .control-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }
        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
        }
        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }
        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        .btn:active {
            transform: translateY(0);
        }
        .status {
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 8px;
            font-size: 0.9em;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            .freq-table {
                grid-template-columns: repeat(13, 1fr);
                gap: 2px;
            }
            .freq-entry {
                min-width: 25px;
                padding: 4px 2px;
            }
            .freq-input {
                width: 20px;
                height: 18px;
                font-size: 0.75em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ”¤ Aristocrat Cipher</h1>
        </div>
        
        <div class="content">
            <div id="statusMessage" class="status" style="display: none;"></div>
            
            <div class="section">
                <h2>Settings</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Key Method:</label>
                        <div class="radio-group">
                            <div class="radio-option">
                                <input type="radio" id="random" name="keyMethod" value="random" checked>
                                <label for="random">Random</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="k1" name="keyMethod" value="k1">
                                <label for="k1">K1</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="k2" name="keyMethod" value="k2">
                                <label for="k2">K2</label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="k3" name="keyMethod" value="k3">
                                <label for="k3">K3</label>
                            </div>
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="checkbox-container">
                            <input type="checkbox" id="autofill" checked>
                            <label for="autofill">Auto-fill matching letters</label>
                        </div>
                        <div class="keyword-guess" id="keywordGuess" style="display: none;">
                            <label>Guess Keyword:</label>
                            <div style="margin-top: 5px;">
                                <input type="text" id="keywordInput" class="keyword-input" placeholder="Enter keyword">
                                <button class="btn-small" onclick="checkKeyword()">Check</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Cipher Text</h2>
                <div class="cipher-section" id="cipherSection">
                    <div class="loading">Loading...</div>
                </div>
            </div>

            <div class="section">
                <h2>Frequency Table</h2>
                <div class="freq-table" id="freqTable">
                </div>
            </div>

            <div class="control-buttons">
                <button class="btn btn-primary" onclick="generateNewProblem()">New Problem</button>
                <button class="btn btn-success" onclick="checkAnswer()">Check Answer</button>
                <button class="btn btn-danger" onclick="showSolution()">Show Solution</button>
                <button class="btn btn-secondary" onclick="clearAnswer()">Clear Answer</button>
            </div>
        </div>
    </div>

    <script>
        let currentPlaintext = '';
        let currentCiphertext = '';
        let cipherMapping = {};
        let reverseMapping = {};
        let letterFrequencies = {};
        let currentKeyword = '';
        let currentMethod = '';
        let quotes = [];
        let words = [];
        let filesLoaded = false;

        // Default data as fallback
        const defaultQuotes = [
            "The quick brown fox jumps over the lazy dog.",
            "To be or not to be, that is the question.",
            "All that glitters is not gold.",
            "A journey of a thousand miles begins with a single step.",
            "The only thing we have to fear is fear itself.",
            "In the beginning was the Word.",
            "Knowledge is power and power corrupts.",
            "Time heals all wounds but leaves ugly scars.",
            "The pen is mightier than the sword."
        ];
        
        const defaultWords = [
            "ARGENTINA", "BUTTERFLY", "ETHICAL", "COMPUTER", "ELEPHANT", "FREEDOM",
            "GOVERNMENT", "HOSPITAL", "INTERNET", "JUSTICE", "KEYBOARD", "LIBERTY",
            "MOUNTAIN", "NEIGHBOR", "OPPOSITE", "PATIENCE", "QUESTION", "REPUBLIC",
            "STRENGTH", "TOGETHER", "UNIVERSE", "VICTORY", "WONDERFUL", "EXAMPLE"
        ];

        function logDebug(message) {
            console.log(message);
        }

        function showStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
            
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 5000);
        }

        // Event listeners for radio buttons
        document.addEventListener('DOMContentLoaded', function() {
            const radioButtons = document.querySelectorAll('input[name="keyMethod"]');
            radioButtons.forEach(radio => {
                radio.addEventListener('change', function() {
                    const keywordGuess = document.getElementById('keywordGuess');
                    if (this.value !== 'random') {
                        keywordGuess.style.display = 'block';
                    } else {
                        keywordGuess.style.display = 'none';
                    }
                });
            });
        });

        async function loadFiles() {
            logDebug('Starting file loading process...');
            
            // Initialize with defaults first
            quotes = [...defaultQuotes];
            words = [...defaultWords];
            
            try {
                // Try to load quotes.txt
                const quotesResponse = await fetch('quotes.txt');
                if (quotesResponse.ok) {
                    const quotesText = await quotesResponse.text();
                    const loadedQuotes = quotesText
                        .split(/[\r\n]+/)
                        .map(quote => quote.trim())
                        .filter(quote => quote.length > 20);
                    
                    if (loadedQuotes.length > 0) {
                        quotes = loadedQuotes;
                        logDebug(`Successfully loaded ${quotes.length} quotes from file`);
                    }
                }

                // Try to load words.txt
                const wordsResponse = await fetch('words.txt');
                if (wordsResponse.ok) {
                    const wordsText = await wordsResponse.text();
                    const loadedWords = wordsText
                        .split(/[\r\n]+/)
                        .map(word => word.trim().toUpperCase())
                        .filter(word => word.length >= 4 && /^[A-Z]+$/.test(word));
                    
                    if (loadedWords.length > 0) {
                        words = loadedWords;
                        logDebug(`Successfully loaded ${words.length} words from file`);
                    }
                }

                showStatus('Files loaded successfully!', 'success');
            } catch (error) {
                logDebug(`Error loading files: ${error.message}`);
                showStatus('Using default data - files not found', 'warning');
            }

            filesLoaded = true;
            generateNewProblem();
        }

        function createKeywordAlphabet(keyword, shift = 0) {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            // Remove duplicates from keyword
            const uniqueKeyword = [...new Set(keyword.toUpperCase().split(''))].filter(c => /[A-Z]/.test(c));
            // Get remaining letters not in keyword
            const remaining = alphabet.split('').filter(c => !uniqueKeyword.includes(c));
            // Combine keyword + remaining letters
            let combined = uniqueKeyword.concat(remaining);
            
            // Apply shift if specified
            if (shift > 0) {
                const shiftAmount = shift % 26;
                combined = combined.slice(shiftAmount).concat(combined.slice(0, shiftAmount));
            }
            
            return combined.join('');
        }

        function generateRandomMapping() {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const shuffled = alphabet.split('').sort(() => Math.random() - 0.5);
            
            // Ensure no self-mapping
            for (let i = 0; i < 26; i++) {
                if (alphabet[i] === shuffled[i]) {
                    // Find a different position to swap with
                    let swapIndex = (i + 1) % 26;
                    while (swapIndex === i || alphabet[swapIndex] === shuffled[swapIndex]) {
                        swapIndex = (swapIndex + 1) % 26;
                    }
                    [shuffled[i], shuffled[swapIndex]] = [shuffled[swapIndex], shuffled[i]];
                }
            }
            
            const mapping = {};
            for (let i = 0; i < 26; i++) {
                mapping[alphabet[i]] = shuffled[i];
            }
            return mapping;
        }

        function generateKeywordMapping(method) {
            const keyword = words[Math.floor(Math.random() * words.length)];
            currentKeyword = keyword;
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const shift = Math.floor(Math.random() * 25) + 1; // Random shift 1-25
            
            logDebug(`Using keyword: ${keyword} for method ${method} with shift ${shift}`);
            
            let plainAlphabet = alphabet;
            let cipherAlphabet = alphabet;
            
            switch (method) {
                case 'k1':
                    // K1: Keyword in plaintext alphabet (shifted), random cipher alphabet
                    plainAlphabet = createKeywordAlphabet(keyword, shift);
                    cipherAlphabet = alphabet.split('').sort(() => Math.random() - 0.5).join('');
                    break;
                case 'k2':
                    // K2: Normal plaintext alphabet, keyword in cipher alphabet (shifted)
                    plainAlphabet = alphabet;
                    cipherAlphabet = createKeywordAlphabet(keyword, shift);
                    break;
                case 'k3':
                    // K3: Keyword in both alphabets (different shifts)
                    const shift2 = (shift + Math.floor(Math.random() * 24) + 1) % 26;
                    plainAlphabet = createKeywordAlphabet(keyword, shift);
                    cipherAlphabet = createKeywordAlphabet(keyword, shift2);
                    break;
            }
            
            // Create mapping
            const mapping = {};
            for (let i = 0; i < 26; i++) {
                mapping[plainAlphabet[i]] = cipherAlphabet[i];
            }
            
            // Ensure no self-mapping by swapping if necessary
            for (let i = 0; i < 26; i++) {
                if (plainAlphabet[i] === cipherAlphabet[i]) {
                    // Find another position to swap with
                    let swapIndex = (i + 1) % 26;
                    while (swapIndex === i || plainAlphabet[swapIndex] === cipherAlphabet[swapIndex]) {
                        swapIndex = (swapIndex + 1) % 26;
                    }
                    // Swap in cipher alphabet
                    const temp = cipherAlphabet[i];
                    cipherAlphabet = cipherAlphabet.substring(0, i) + cipherAlphabet[swapIndex] + 
                                   cipherAlphabet.substring(i + 1, swapIndex) + temp + 
                                   cipherAlphabet.substring(swapIndex + 1);
                    
                    // Update mapping
                    mapping[plainAlphabet[i]] = cipherAlphabet[i];
                    mapping[plainAlphabet[swapIndex]] = cipherAlphabet[swapIndex];
                }
            }
            
            logDebug(`Plain alphabet: ${plainAlphabet}`);
            logDebug(`Cipher alphabet: ${cipherAlphabet}`);
            
            return mapping;
        }

        function encryptText(text, mapping) {
            return text.toUpperCase().split('').map(char => {
                if (char.match(/[A-Z]/)) {
                    return mapping[char];
                }
                return char;
            }).join('');
        }

        function calculateFrequencies(text) {
            const frequencies = {};
            const letters = text.replace(/[^A-Z]/g, '');
            
            for (const letter of letters) {
                frequencies[letter] = (frequencies[letter] || 0) + 1;
            }
            
            return frequencies;
        }

        function getSelectedKeyMethod() {
            const radios = document.querySelectorAll('input[name="keyMethod"]');
            for (let radio of radios) {
                if (radio.checked) {
                    return radio.value;
                }
            }
            return 'random';
        }

        function generateNewProblem() {
            if (!filesLoaded) {
                logDebug('Files not loaded yet, waiting...');
                return;
            }

            logDebug('Generating new aristocrat problem...');

            // Select random quote
            const quote = quotes[Math.floor(Math.random() * quotes.length)];
            currentPlaintext = quote.replace(/[^a-zA-Z\s]/g, '').toUpperCase();
            
            // Generate cipher mapping based on selected method
            const method = getSelectedKeyMethod();
            currentMethod = method;
            
            if (method === 'random') {
                cipherMapping = generateRandomMapping();
                currentKeyword = '';
            } else {
                cipherMapping = generateKeywordMapping(method);
            }
            
            // Create reverse mapping
            reverseMapping = {};
            for (const [plain, cipher] of Object.entries(cipherMapping)) {
                reverseMapping[cipher] = plain;
            }
            
            // Encrypt the text
            currentCiphertext = encryptText(currentPlaintext, cipherMapping);
            
            // Calculate frequencies
            letterFrequencies = calculateFrequencies(currentCiphertext);
            
            logDebug(`Plaintext: "${currentPlaintext}"`);
            logDebug(`Ciphertext: "${currentCiphertext}"`);
            logDebug('Cipher mapping:', cipherMapping);
            if (currentKeyword) {
                logDebug(`Keyword: ${currentKeyword}`);
            }
            
            updateDisplay();
        }

        function wrapTextIntoLines(text, maxWidth = 800) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = [];
            let currentWidth = 0;
            const charWidth = 30; // Approximate width per character including spacing
            
            for (let word of words) {
                const wordWidth = word.length * charWidth;
                
                if (currentWidth + wordWidth > maxWidth && currentLine.length > 0) {
                    lines.push(currentLine.join(' '));
                    currentLine = [word];
                    currentWidth = wordWidth;
                } else {
                    currentLine.push(word);
                    currentWidth += wordWidth + (currentLine.length > 1 ? charWidth : 0); // Add space width
                }
            }
            
            if (currentLine.length > 0) {
                lines.push(currentLine.join(' '));
            }
            
            return lines;
        }

        function updateDisplay() {
            const cipherSection = document.getElementById('cipherSection');
            cipherSection.innerHTML = '';
            
            // Wrap text into lines to prevent word breaking
            const lines = wrapTextIntoLines(currentCiphertext);
            
            lines.forEach((line, lineIndex) => {
                const textLine = document.createElement('div');
                textLine.className = 'cipher-text-line';
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === ' ') {
                        // Add space marker
                        const spaceDiv = document.createElement('div');
                        spaceDiv.className = 'space-marker';
                        spaceDiv.innerHTML = '&nbsp;';
                        textLine.appendChild(spaceDiv);
                    } else if (char.match(/[A-Z]/)) {
                        // Add cipher letter with input box
                        const pairDiv = document.createElement('div');
                        pairDiv.className = 'cipher-pair';
                        
                        const cipherDiv = document.createElement('div');
                        cipherDiv.className = 'cipher-letter';
                        cipherDiv.textContent = char;
                        
                        const answerInput = document.createElement('input');
                        answerInput.type = 'text';
                        answerInput.className = 'answer-box';
                        answerInput.maxLength = 1;
                        answerInput.dataset.cipher = char;
                        answerInput.dataset.position = `${lineIndex}-${i}`;
                        
                        answerInput.addEventListener('input', handleAnswerInput);
                        answerInput.addEventListener('keydown', handleKeyDown);
                        
                        pairDiv.appendChild(cipherDiv);
                        pairDiv.appendChild(answerInput);
                        textLine.appendChild(pairDiv);
                    }
                }
                
                cipherSection.appendChild(textLine);
            });
            
            updateFrequencyTable();
        }

        function handleAnswerInput(e) {
            const value = e.target.value.toUpperCase();
            if (value.match(/[A-Z]/)) {
                e.target.value = value;
                
                // Auto-fill if enabled
                if (document.getElementById('autofill').checked) {
                    const cipherLetter = e.target.dataset.cipher;
                    const allBoxes = document.querySelectorAll(`input[data-cipher="${cipherLetter}"]`);
                    allBoxes.forEach(box => {
                        box.value = value;
                    });
                    
                    // Update frequency table
                    const freqInput = document.querySelector(`input[data-freq-cipher="${cipherLetter}"]`);
                    if (freqInput) {
                        freqInput.value = value;
                    }
                }
                
                // Move to next box
                moveToNextBox(e.target);
            } else {
                e.target.value = '';
            }
        }

        function handleKeyDown(e) {
            if (e.key === 'Backspace' && !e.target.value) {
                moveToPrevBox(e.target);
            }
        }

        function moveToNextBox(currentBox) {
            const allBoxes = Array.from(document.querySelectorAll('.answer-box'));
            const currentIndex = allBoxes.indexOf(currentBox);
            if (currentIndex < allBoxes.length - 1) {
                allBoxes[currentIndex + 1].focus();
            }
        }

        function moveToPrevBox(currentBox) {
            const allBoxes = Array.from(document.querySelectorAll('.answer-box'));
            const currentIndex = allBoxes.indexOf(currentBox);
            if (currentIndex > 0) {
                allBoxes[currentIndex - 1].focus();
            }
        }

        function updateFrequencyTable() {
            const freqTable = document.getElementById('freqTable');
            freqTable.innerHTML = '';
            
            // Create entries for all 26 letters in alphabetical order
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            
            for (let i = 0; i < 26; i++) {
                const letter = alphabet[i];
                const count = letter
