<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codebusters Practice</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .content {
            padding: 30px;
        }

        .cryptogram-display {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            line-height: 1.6;
            min-height: 200px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .cipher-line {
            margin-bottom: 5px;
            color: #2c3e50;
            font-weight: bold;
        }

        .plain-line {
            margin-bottom: 20px;
            color: #27ae60;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="text"] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        button {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }

        button:active {
            transform: translateY(0);
        }

        button.danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        button.success {
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        .puzzle-options {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .option-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .option-group h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .radio-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .frequency-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid #e9ecef;
        }

        .frequency-section h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
        }

        .frequency-table {
            display: grid;
            grid-template-columns: repeat(26, 1fr);
            gap: 2px;
            margin-bottom: 15px;
        }

        .freq-cell {
            text-align: center;
            padding: 8px 2px;
            background: white;
            border: 1px solid #ddd;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .freq-header {
            background: #3498db;
            color: white;
        }

        .freq-input {
            width: 30px;
            height: 35px;
            text-align: center;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 14px;
        }

        .freq-input:focus {
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .input-row {
            display: grid;
            grid-template-columns: repeat(26, 1fr);
            gap: 2px;
            margin-top: 10px;
        }

        .status {
            background: #e8f4fd;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            font-weight: bold;
            color: #2c3e50;
        }

        .substitution-display {
            color: #27ae60;
        }

        .underscore {
            color: #95a5a6;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }

            .content {
                padding: 20px;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .puzzle-options {
                flex-direction: column;
            }

            .frequency-table {
                grid-template-columns: repeat(13, 1fr);
            }

            .input-row {
                grid-template-columns: repeat(13, 1fr);
            }

            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê Codebusters Practice</h1>
        </div>
        
        <div class="content">
            <div class="puzzle-options">
                <div class="option-group">
                    <h4>Puzzle Type</h4>
                    <div class="radio-group">
                        <label class="radio-item">
                            <input type="radio" name="puzzleType" value="aristocrat" checked>
                            Aristocrat
                        </label>
                        <label class="radio-item">
                            <input type="radio" name="puzzleType" value="patristocrat">
                            Patristocrat
                        </label>
                        <label class="radio-item">
                            <input type="radio" name="puzzleType" value="xenocrypt">
                            Xenocrypt
                        </label>
                    </div>
                </div>
                
                <div class="option-group">
                    <h4>Cipher Mapping</h4>
                    <div class="radio-group">
                        <label class="radio-item">
                            <input type="radio" name="cipherType" value="random" checked>
                            Random
                        </label>
                        <label class="radio-item">
                            <input type="radio" name="cipherType" value="k1">
                            K1 (Keyword)
                        </label>
                        <label class="radio-item">
                            <input type="radio" name="cipherType" value="k2">
                            K2 (Keyword)
                        </label>
                        <label class="radio-item">
                            <input type="radio" name="cipherType" value="k3">
                            K3 (Keyword)
                        </label>
                    </div>
                </div>
            </div>

            <div class="cryptogram-display" id="cryptogramDisplay">
                Loading puzzle...
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Substitution (e.g., X E):</label>
                    <input type="text" id="substitutionInput" placeholder="X E" maxlength="3">
                    <button onclick="processSubstitution()">Apply</button>
                </div>
                <button onclick="checkSolution()" class="success">Check Solution</button>
                <button onclick="loadNewPuzzle()">New Puzzle</button>
                <button onclick="showHint()">First Word Hint</button>
                <button onclick="guessKeyword()">Guess Keyword</button>
                <button onclick="revealAnswer()" class="danger">Reveal Answer</button>
            </div>

            <div class="frequency-section">
                <h3>Letter Frequency & Substitution</h3>
                <div class="frequency-table" id="frequencyTable">
                    <!-- Frequency display will be generated here -->
                </div>
                <div class="input-row" id="inputRow">
                    <!-- Input fields will be generated here -->
                </div>
            </div>

            <div class="status" id="statusLabel">
                Enter a substitution (e.g., X E) in the field above or type directly in the frequency table
            </div>
        </div>
    </div>

    <script>
        // Game state
        let currentQuote = '';
        let encodedText = '';
        let cipher = {};
        let guesses = {};
        let isAristocrat = true;
        let isXenocrypt = false;
        let currentKeyword = '';
        let mappingType = 'random';
        let firstWord = '';

        // Sample quotes (you can expand this)
        const englishQuotes = [
            "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG",
            "TO BE OR NOT TO BE THAT IS THE QUESTION",
            "ALL THE WORLD IS A STAGE AND ALL THE MEN AND WOMEN MERELY PLAYERS",
            "LIFE IS WHAT HAPPENS WHEN YOU ARE BUSY MAKING OTHER PLANS",
            "THE ONLY WAY TO DO GREAT WORK IS TO LOVE WHAT YOU DO",
            "INNOVATION DISTINGUISHES BETWEEN A LEADER AND A FOLLOWER",
            "SUCCESS IS NOT FINAL FAILURE IS NOT FATAL IT IS THE COURAGE TO CONTINUE THAT COUNTS",
            "THE FUTURE BELONGS TO THOSE WHO BELIEVE IN THE BEAUTY OF THEIR DREAMS"
        ];

        const spanishQuotes = [
            "EL ZORRO MARR√ìN R√ÅPIDO SALTA SOBRE EL PERRO PEREZOSO",
            "LA VIDA ES LO QUE PASA MIENTRAS EST√ÅS OCUPADO HACIENDO OTROS PLANES",
            "EL √öNICO MODO DE HACER UN GRAN TRABAJO ES AMAR LO QUE HACES",
            "LA INNOVACI√ìN DISTINGUE ENTRE UN L√çDER Y UN SEGUIDOR",
            "EL FUTURO PERTENECE A AQUELLOS QUE CREEN EN LA BELLEZA DE SUS SUE√ëOS"
        ];

        const keywords = [
            "PUZZLE", "CIPHER", "SECRET", "HIDDEN", "MYSTERY", "ENIGMA", "CODING", "CRYPTO",
            "SOLVER", "BREAK", "DECODE", "REVEAL", "ANSWER", "CLUES", "LETTERS", "ALPHABET"
        ];

        // Initialize the game
        function init() {
            setupEventHandlers();
            createFrequencyTable();
            loadNewPuzzle();
        }

        function setupEventHandlers() {
            // Puzzle type handlers
            document.querySelectorAll('input[name="puzzleType"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    isAristocrat = this.value === 'aristocrat';
                    isXenocrypt = this.value === 'xenocrypt';
                    loadNewPuzzle();
                });
            });

            // Cipher type handlers
            document.querySelectorAll('input[name="cipherType"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    mappingType = this.value;
                    loadNewPuzzle();
                });
            });

            // Substitution input handler
            document.getElementById('substitutionInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    processSubstitution();
                }
            });
        }

        function createFrequencyTable() {
            const table = document.getElementById('frequencyTable');
            const inputRow = document.getElementById('inputRow');
            
            table.innerHTML = '';
            inputRow.innerHTML = '';

            // Create header row with letters
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const headerCell = document.createElement('div');
                headerCell.className = 'freq-cell freq-header';
                headerCell.textContent = letter;
                table.appendChild(headerCell);
            }

            // Create frequency count row
            for (let i = 0; i < 26; i++) {
                const freqCell = document.createElement('div');
                freqCell.className = 'freq-cell';
                freqCell.id = `freq-${String.fromCharCode(65 + i)}`;
                freqCell.textContent = '0';
                table.appendChild(freqCell);
            }

            // Create input row
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'freq-input';
                input.maxLength = 1;
                input.id = `input-${letter}`;
                
                input.addEventListener('input', function() {
                    const value = this.value.toUpperCase();
                    if (value && /[A-Z]/.test(value)) {
                        guesses[letter] = value;
                        this.value = value;
                    } else {
                        delete guesses[letter];
                        this.value = '';
                    }
                    updateDisplay();
                    updateFrequencyTable();
                });

                inputRow.appendChild(input);
            }
        }

        function loadNewPuzzle() {
            guesses = {};
            
            // Select quote based on puzzle type
            const quotes = isXenocrypt ? spanishQuotes : englishQuotes;
            currentQuote = quotes[Math.floor(Math.random() * quotes.length)];
            
            // Get first word for hints
            const words = currentQuote.trim().split(/\s+/);
            firstWord = words.length > 0 ? words[0].replace(/[^A-Z]/g, '') : '';

            // Generate cipher
            if (mappingType === 'random') {
                cipher = generateRandomCipher();
                currentKeyword = '';
            } else {
                currentKeyword = keywords[Math.floor(Math.random() * keywords.length)];
                cipher = generateKeywordCipher(currentKeyword, mappingType);
            }

            // Encode text
            encodedText = isAristocrat ? encodeAristocrat(currentQuote) : encodePatristocrat(currentQuote);

            // Clear input fields
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                document.getElementById(`input-${letter}`).value = '';
            }

            updateDisplay();
            updateFrequencyTable();
            updateStatus(`New ${isXenocrypt ? 'Xenocrypt' : isAristocrat ? 'Aristocrat' : 'Patristocrat'} puzzle loaded!`);
        }

        function generateRandomCipher() {
            const plainAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
            const cipherAlphabet = [...plainAlphabet];
            
            // Fisher-Yates shuffle
            for (let i = cipherAlphabet.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [cipherAlphabet[i], cipherAlphabet[j]] = [cipherAlphabet[j], cipherAlphabet[i]];
            }

            // Ensure no letter maps to itself
            for (let i = 0; i < 26; i++) {
                if (plainAlphabet[i] === cipherAlphabet[i]) {
                    // Swap with next position (or first if at end)
                    const swapIndex = (i + 1) % 26;
                    [cipherAlphabet[i], cipherAlphabet[swapIndex]] = [cipherAlphabet[swapIndex], cipherAlphabet[i]];
                }
            }

            const result = {};
            for (let i = 0; i < 26; i++) {
                result[plainAlphabet[i]] = cipherAlphabet[i];
            }
            return result;
        }

        function generateKeywordCipher(keyword, type) {
            const plainAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
            let cipherAlphabet = [];

            // Remove duplicates from keyword
            const cleanKeyword = [...new Set(keyword.toUpperCase().split(''))].filter(c => /[A-Z]/.test(c));

            if (type === 'k1') {
                // K1: keyword + remaining alphabet
                cipherAlphabet = [...cleanKeyword];
                for (let c of plainAlphabet) {
                    if (!cipherAlphabet.includes(c)) {
                        cipherAlphabet.push(c);
                    }
                }
            } else if (type === 'k2') {
                // K2: interleave keyword with alphabet
                const remaining = plainAlphabet.filter(c => !cleanKeyword.includes(c));
                let keyIndex = 0, alphaIndex = 0;
                
                while (cipherAlphabet.length < 26) {
                    if (keyIndex < cleanKeyword.length) {
                        cipherAlphabet.push(cleanKeyword[keyIndex++]);
                    }
                    if (alphaIndex < remaining.length && cipherAlphabet.length < 26) {
                        cipherAlphabet.push(remaining[alphaIndex++]);
                    }
                }
            } else if (type === 'k3') {
                // K3: keyword + reversed remaining alphabet
                cipherAlphabet = [...cleanKeyword];
                const remaining = plainAlphabet.filter(c => !cleanKeyword.includes(c)).reverse();
                cipherAlphabet.push(...remaining);
            }

            // Apply random shift
            const shift = Math.floor(Math.random() * 26);
            cipherAlphabet = cipherAlphabet.slice(shift).concat(cipherAlphabet.slice(0, shift));

            // Ensure no letter maps to itself
            for (let i = 0; i < 26; i++) {
                if (plainAlphabet[i] === cipherAlphabet[i]) {
                    const swapIndex = (i + 1) % 26;
                    [cipherAlphabet[i], cipherAlphabet[swapIndex]] = [cipherAlphabet[swapIndex], cipherAlphabet[i]];
                }
            }

            const result = {};
            for (let i = 0; i < 26; i++) {
                result[plainAlphabet[i]] = cipherAlphabet[i];
            }
            return result;
        }

        function encodeAristocrat(text) {
            return text.split('').map(c => {
                if (/[A-Z]/.test(c)) return cipher[c];
                if (/[a-z]/.test(c)) return cipher[c.toUpperCase()];
                return c;
            }).join('');
        }

        function encodePatristocrat(text) {
            return text.split('').map(c => {
                if (/[A-Za-z]/.test(c)) return cipher[c.toUpperCase()];
                return '';
            }).join('');
        }

        function updateDisplay() {
            const display = document.getElementById('cryptogramDisplay');
            
            if (isAristocrat) {
                // Aristocrat format: preserve spaces and punctuation
                const lines = splitIntoLines(encodedText, 60);
                let html = '';
                
                lines.forEach(line => {
                    // Cipher line
                    html += '<div class="cipher-line">';
                    for (let c of line) {
                        html += `<span>${c}</span>`;
                    }
                    html += '</div>';
                    
                    // Plain line
                    html += '<div class="plain-line">';
                    for (let c of line) {
                        if (/[A-Z]/.test(c)) {
                            if (guesses[c]) {
                                html += `<span class="substitution-display">${guesses[c]}</span>`;
                            } else {
                                html += `<span class="underscore">_</span>`;
                            }
                        } else {
                            html += `<span>${c}</span>`;
                        }
                    }
                    html += '</div>';
                });
                
                display.innerHTML = html;
            } else {
                // Patristocrat format: groups of 5 letters
                const cleanText = encodedText.replace(/[^A-Z]/g, '');
                const groups = [];
                for (let i = 0; i < cleanText.length; i += 5) {
                    groups.push(cleanText.slice(i, i + 5));
                }
                
                let html = '';
                
                // Cipher line
                html += '<div class="cipher-line">' + groups.join(' ') + '</div>';
                
                // Plain line
                html += '<div class="plain-line">';
                groups.forEach((group, index) => {
                    if (index > 0) html += ' ';
                    for (let c of group) {
                        if (guesses[c]) {
                            html += `<span class="substitution-display">${guesses[c]}</span>`;
                        } else {
                            html += `<span class="underscore">_</span>`;
                        }
                    }
                });
                html += '</div>';
                
                display.innerHTML = html;
            }
        }

        function splitIntoLines(text, maxLength) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            
            words.forEach(word => {
                if (currentLine.length + word.length + 1 <= maxLength) {
                    currentLine += (currentLine ? ' ' : '') + word;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            });
            
            if (currentLine) lines.push(currentLine);
            return lines;
        }

        function updateFrequencyTable() {
            // Count frequencies
            const frequencies = {};
            for (let i = 0; i < 26; i++) {
                frequencies[String.fromCharCode(65 + i)] = 0;
            }
            
            for (let c of encodedText) {
                if (/[A-Z]/.test(c)) {
                    frequencies[c]++;
                }
            }
            
            // Update display
            for (let i = 0; i < 26; i++) {
                const letter = String.fromCharCode(65 + i);
                document.getElementById(`freq-${letter}`).textContent = frequencies[letter];
                
                // Update input field
                const input = document.getElementById(`input-${letter}`);
                input.value = guesses[letter] || '';
            }
        }

        function processSubstitution() {
            const input = document.getElementById('substitutionInput').value.trim().toUpperCase();
            const match = input.match(/^([A-Z])\s+([A-Z])$/);
            
            if (match) {
                const [, cipherLetter, plainLetter] = match;
                guesses[cipherLetter] = plainLetter;
                document.getElementById(`input-${cipherLetter}`).value = plainLetter;
                updateDisplay();
                updateFrequencyTable();
                updateStatus(`Substituted ${cipherLetter} with ${plainLetter}`);
                document.getElementById('substitutionInput').value = '';
            } else {
                updateStatus("Invalid format. Please use format like 'X E'");
            }
        }

        function checkSolution() {
            let decodedText = '';
            for (let c of encodedText) {
                if (/[A-Z]/.test(c)) {
                    decodedText += guesses[c] || ' ';
                } else {
                    decodedText += c;
                }
            }
            
            const normalize = text => text.toUpperCase().replace(/[^A-Z]/g, '');
            
            if (normalize(decodedText) === normalize(currentQuote)) {
                let message = `üéâ Correct!\n\nOriginal Quote:\n${currentQuote}`;
                if (currentKeyword && mappingType !== 'random') {
                    message += `\n\nCipher: ${mappingType.toUpperCase()}\nKeyword: ${currentKeyword}`;
                    if (isXenocrypt) {
                        message += '\nType: Xenocrypt (Spanish quote with English keyword)';
                    }
                }
                alert(message);
                updateStatus('Correct! üéâ');
            } else {
                updateStatus('Incorrect. Keep trying! ü§î');
            }
        }

        function showHint() {
            if (!isAristocrat && firstWord) {
                alert(`üí° Hint: The first word is "${firstWord}"`);
            } else {
                alert('Hints are only available for Patristocrat puzzles.');
            }
        }

        function guessKeyword() {
            if (mappingType === 'random') {
                alert('Keyword guessing is only available for K1, K2, and K3 cipher types.');
                return;
            }
            
            const guess = prompt(`Enter your guess for the ${mappingType.toUpperCase()} keyword:`);
            if (guess) {
                const cleanGuess = guess.trim().toUpperCase();
                if (cleanGuess === currentKeyword) {
                    alert(`üéØ Correct! The keyword is: ${currentKeyword}`);
                    updateStatus(`Keyword guessed correctly: ${currentKeyword}`);
                } else {
                    alert('‚ùå Incorrect. Try again!');
                    updateStatus('Incorrect keyword guess.');
                }
            }
        }

        function revealAnswer() {
            if (confirm('Are you sure you want to see the answer?')) {
                // Create reverse mapping
                const reverseMapping = {};
                for (let [plain, cipher] of Object.entries(cipher)) {
                    reverseMapping[cipher] = plain;
                }
                
                // Fill in all guesses
                guesses = { ...reverseMapping };
                
                // Update input fields
                for (let i = 0; i < 26; i++) {
                    const letter = String.fromCharCode(65 + i);
                    document.getElementById(`input-${letter}`).value = guesses[letter] || '';
                }
                
                updateDisplay();
                updateFrequencyTable();
                
                let message = `üìù Solution:\n\n${currentQuote}`;
                if (currentKeyword && mappingType !== 'random') {
                    message += `\n\nCipher: ${mappingType.toUpperCase()}\nKeyword: ${currentKeyword}`;
                }
                alert(message);
                updateStatus('Answer revealed üëÅÔ∏è');
            }
        }

        function updateStatus(message) {
            document.getElementById('statusLabel').textContent = message;
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
